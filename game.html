<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Aromat Pizza 1986</title>
  <style>
    :root { color-scheme: dark; }
    body{
      margin:0; height:100vh; display:flex; align-items:center; justify-content:center;
      background:#0b0f1a; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      touch-action: none;
    }
    .wrap{
      display:flex; flex-direction:column; gap:10px; align-items:center;
      padding:14px 16px; border:2px solid #2a3350; background:#0f1629;
      box-shadow: 0 0 0 4px #070a12, 0 0 0 6px #2a3350;
    }
    canvas{
      width:min(92vw, 720px);
      height:auto;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      border:2px solid #2a3350;
      background:#080b14;
      touch-action: none;
    }
    .hud{
      width:min(92vw, 720px);
      display:flex; justify-content:space-between; gap:12px; flex-wrap:wrap;
      color:#c7d2fe; font-size:14px;
    }
    .hud b{ color:#fbbf24; }
    .help{
      width:min(92vw, 720px);
      color:#8aa0ff; font-size:12px; line-height:1.35;
      opacity:0.9;
    }
    .btnrow{ display:flex; gap:10px; flex-wrap:wrap; justify-content:center; }
    button{
      font:inherit; font-size:13px;
      padding:10px 12px;
      color:#e5e7eb; background:#111a33;
      border:2px solid #2a3350;
      cursor:pointer;
      touch-action: manipulation;
      min-width: 92px;
    }
    button:active{ border-color:#6b82ff; transform: translateY(1px); }
    .touchpad{
      width:min(92vw, 720px);
      display:flex; gap:10px; justify-content:center; flex-wrap:wrap;
    }
    .touchpad button{
      min-width: 110px;
      font-size: 14px;
    }
    .touchpad .big{
      min-width: 160px;
      font-weight: 700;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div>Score: <b id="score">0</b></div>
      <div>Tempo: <b id="time">30.0</b>s</div>
      <div>Combo: <b id="combo">x1</b></div>
    </div>

    <canvas id="game" width="320" height="180" aria-label="Aromat Pizza 1986"></canvas>

    <div class="btnrow">
      <button id="startBtn">Start / Restart</button>
      <button id="muteBtn">Mute: OFF</button>
    </div>

    <div class="touchpad">
      <button id="leftBtn">◀ SINISTRA</button>
      <button id="rightBtn">DESTRA ▶</button>
      <button id="fireBtn" class="big">SPARA</button>
    </div>

    <div class="help">
      Desktop: <b>← →</b> o <b>A/D</b> per muovere. <b>Spazio</b> per sparare.<br>
      Touch: <b>trascina</b> sul canvas per muovere. <b>tap</b> per sparare (o usa i bottoni).
    </div>
  </div>

<script>
(() => {
  const c = document.getElementById('game');
  const ctx = c.getContext('2d', { alpha: false });

  const scoreEl = document.getElementById('score');
  const timeEl  = document.getElementById('time');
  const comboEl = document.getElementById('combo');
  const startBtn= document.getElementById('startBtn');
  const muteBtn = document.getElementById('muteBtn');

  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const fireBtn = document.getElementById('fireBtn');

  // ===== tiny beeps =====
  let audioCtx = null;
  let muted = false;
  function beep(freq=440, dur=0.05, type='square', gain=0.03) {
    if (muted) return;
    try {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const t0 = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, t0);
      g.gain.setValueAtTime(gain, t0);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
      o.connect(g); g.connect(audioCtx.destination);
      o.start(t0); o.stop(t0 + dur);
    } catch {}
  }

  muteBtn.addEventListener('click', () => {
    muted = !muted;
    muteBtn.textContent = `Mute: ${muted ? 'ON' : 'OFF'}`;
    if (!muted) beep(660, 0.06, 'square', 0.02);
  });

  // ===== Game state =====
  const W = c.width, H = c.height;
  let running = false;

  const player = {
    x: W/2, y: H-26,
    w: 26, h: 40,
    vx: 0,
    speed: 150,
    cooldown: 0
  };

  const pizza = { x: W/2, y: 58, r: 22, vx: 55 };
  const bullets = [];
  const crumbs  = [];
  const stars   = [];
  let score = 0;
  let combo = 1;
  let comboTimer = 0;
  let timeLeft = 30.0;

  for (let i=0; i<60; i++){
    stars.push({ x: Math.random()*W, y: Math.random()*H, s: Math.random()<0.8 ? 1 : 2, v: 10 + Math.random()*25 });
  }

  // ===== Input (keyboard + on-screen) =====
  const keys = new Set();
  addEventListener('keydown', (e) => {
    if (['ArrowLeft','ArrowRight','Space','KeyA','KeyD'].includes(e.code)) e.preventDefault();
    keys.add(e.code);
    if (e.code === 'Space' && running) tryShoot();
  }, { passive:false });
  addEventListener('keyup', (e) => keys.delete(e.code));

  // on-screen buttons (touch/mouse)
  let holdLeft = false, holdRight = false;
  function bindHold(btn, onDown, onUp){
    const down = (e)=>{ e.preventDefault(); onDown(); };
    const up = (e)=>{ e.preventDefault(); onUp(); };
    btn.addEventListener('pointerdown', down);
    btn.addEventListener('pointerup', up);
    btn.addEventListener('pointercancel', up);
    btn.addEventListener('pointerleave', up);
  }
  bindHold(leftBtn, ()=>{ holdLeft=true; }, ()=>{ holdLeft=false; });
  bindHold(rightBtn, ()=>{ holdRight=true; }, ()=>{ holdRight=false; });
  fireBtn.addEventListener('pointerdown', (e)=>{ e.preventDefault(); if (running) tryShoot(); });

  function tryShoot(){
    if (player.cooldown > 0) return;
    player.cooldown = 0.13;
    bullets.push({
      x: player.x + (Math.random()-0.5)*3,
      y: player.y - player.h/2 + 2,
      vx: (Math.random()-0.5)*22,
      vy: -240 - Math.random()*70,
      life: 1.2
    });
    beep(520, 0.04, 'square', 0.02);
  }

  // ===== Touch on canvas: drag to move, tap to shoot =====
  let activePointers = new Map(); // pointerId -> {x,y}
  let draggingId = null;
  let dragStartX = 0;
  let playerStartX = 0;
  let lastTapTime = 0;

  c.addEventListener('pointerdown', (e) => {
    c.setPointerCapture(e.pointerId);
    activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

    // First pointer becomes drag controller
    if (draggingId === null){
      draggingId = e.pointerId;
      dragStartX = e.clientX;
      playerStartX = player.x;
    } else {
      // second finger: shoot immediately
      if (running) tryShoot();
    }
    e.preventDefault();
  });

  c.addEventListener('pointermove', (e) => {
    if (!activePointers.has(e.pointerId)) return;
    activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

    if (e.pointerId === draggingId){
      const dx = (e.clientX - dragStartX);
      // scale dx from CSS pixels to canvas units
      const rect = c.getBoundingClientRect();
      const scale = W / rect.width;
      player.x = clamp(playerStartX + dx*scale, 16, W-16);
    }
    e.preventDefault();
  });

  c.addEventListener('pointerup', (e) => {
    // tap-to-shoot (quick release without meaningful drag)
    const wasDragging = (e.pointerId === draggingId);
    const rect = c.getBoundingClientRect();
    const scale = W / rect.width;
    const dx = wasDragging ? (e.clientX - dragStartX) * scale : 999;

    // consider tap if little movement + short interval
    const now = performance.now();
    const isTap = Math.abs(dx) < 6;

    if (isTap && running){
      // basic anti-doppio click involontario
      if (now - lastTapTime > 60) tryShoot();
      lastTapTime = now;
    }

    activePointers.delete(e.pointerId);
    if (e.pointerId === draggingId){
      draggingId = null;
      // if there is another pointer still down, assign it
      for (const [pid, p] of activePointers){
        draggingId = pid;
        dragStartX = p.x;
        playerStartX = player.x;
        break;
      }
    }
    e.preventDefault();
  });

  c.addEventListener('pointercancel', (e) => {
    activePointers.delete(e.pointerId);
    if (e.pointerId === draggingId) draggingId = null;
    e.preventDefault();
  });

  // ===== Helpers =====
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function rnd(a,b){ return a + Math.random()*(b-a); }

  function reset(){
    bullets.length = 0;
    crumbs.length = 0;
    score = 0;
    combo = 1;
    comboTimer = 0;
    timeLeft = 30.0;
    player.x = W/2;
    player.cooldown = 0;
    pizza.x = W/2;
    pizza.vx = 55;
    scoreEl.textContent = score;
    comboEl.textContent = 'x1';
    timeEl.textContent = timeLeft.toFixed(1);
  }

  startBtn.addEventListener('click', () => {
    if (!running) {
      reset();
      running = true;
      last = performance.now();
      beep(880, 0.06, 'square', 0.03);
      requestAnimationFrame(loop);
    } else {
      reset();
      beep(740, 0.06, 'square', 0.03);
    }
  });

  // ===== Pixel drawing helpers =====
  function pxRect(x,y,w,h,color){
    ctx.fillStyle = color;
    ctx.fillRect(x|0, y|0, w|0, h|0);
  }
  function pxText(text, x, y, color){
    ctx.fillStyle = color;
    ctx.font = '10px monospace';
    ctx.fillText(text, x|0, y|0);
  }

  // ===== Aromat sprite (più simile alla foto) =====
  function drawAromatJar(x,y){
    const w = player.w, h = player.h;
    const left = (x - w/2)|0;
    const top  = (y - h/2)|0;

    // shadow
    pxRect(left-2, top+3, w+4, h+4, '#060814');

    // body outer (yellow)
    pxRect(left, top+6, w, h-6, '#f6d32d');
    // subtle highlight
    pxRect(left+2, top+8, w-4, h-10, '#ffe88a');

    // top cap (red)
    pxRect(left+2, top, w-4, 7, '#d3181c');
    pxRect(left+3, top+1, w-6, 3, '#ff4b4b'); // shine

    // green label band
    pxRect(left+1, top+16, w-2, 14, '#0f7a3a');
    pxRect(left+2, top+17, w-4, 12, '#12a14a'); // inner

    // "Aromat" text (pixel vibes)
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 11px monospace';
    ctx.fillText('Aromat', left+3, top+27);

    // small "Original" above (tiny)
    ctx.fillStyle = '#e7f7ff';
    ctx.font = '8px monospace';
    ctx.fillText('ORIGINAL', left+6, top+15);

    // Swiss flag (red square + white cross)
    const fx = left + w - 10, fy = top + 31;
    pxRect(fx, fy, 7, 7, '#d3181c');
    pxRect(fx+3, fy+1, 1, 5, '#ffffff');
    pxRect(fx+1, fy+3, 5, 1, '#ffffff');

    // little red mascot-ish (simple pixel dude)
    const mx = left + 5, my = top + 33;
    pxRect(mx+2, my, 3, 3, '#d3181c');       // head
    pxRect(mx+3, my+1, 1, 1, '#ffffff');     // face dot
    pxRect(mx+2, my+3, 3, 3, '#d3181c');     // body
    pxRect(mx+1, my+4, 1, 1, '#d3181c');     // arm
    pxRect(mx+5, my+4, 1, 1, '#d3181c');     // arm
    pxRect(mx+2, my+6, 1, 2, '#d3181c');     // leg
    pxRect(mx+4, my+6, 1, 2, '#d3181c');     // leg

    // bottom edge darker
    pxRect(left, top+h-2, w, 2, '#caa516');
  }

  function drawPizza(x,y,r){
    ctx.fillStyle = '#d97706';
    ctx.beginPath(); ctx.arc(x, y, r+4, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = '#fef3c7';
    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = '#ef4444';
    for (let i=0;i<6;i++){
      const a = i* (Math.PI*2/6) + 0.3;
      ctx.beginPath();
      ctx.arc(x + Math.cos(a)* (r*0.45), y + Math.sin(a)* (r*0.35), 3, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.strokeStyle = '#f59e0b';
    ctx.lineWidth = 1;
    for (let i=0;i<4;i++){
      const a = i*(Math.PI/2);
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.cos(a)* (r+3), y + Math.sin(a)* (r+3));
      ctx.stroke();
    }
  }

  function drawCRT(){
    ctx.fillStyle = 'rgba(0,0,0,0.18)';
    for (let y=0; y<H; y+=2) ctx.fillRect(0, y, W, 1);

    const g = ctx.createRadialGradient(W/2,H/2,20,W/2,H/2,140);
    g.addColorStop(0,'rgba(0,0,0,0)');
    g.addColorStop(1,'rgba(0,0,0,0.35)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);
  }

  // ===== Loop =====
  let last = performance.now();

  function loop(now){
    if (!running) return;
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;

    update(dt);
    render();

    if (running) requestAnimationFrame(loop);
  }

  function update(dt){
    timeLeft -= dt;
    if (timeLeft <= 0){
      timeLeft = 0;
      running = false;
      beep(220, 0.12, 'square', 0.03);
      return;
    }
    timeEl.textContent = timeLeft.toFixed(1);

    // keyboard + hold buttons
    let dir = 0;
    if (keys.has('ArrowLeft') || keys.has('KeyA') || holdLeft) dir -= 1;
    if (keys.has('ArrowRight') || keys.has('KeyD') || holdRight) dir += 1;

    // if user is dragging on canvas, we already set player.x directly
    // but we still allow slight keyboard nudges
    player.vx = dir * player.speed;
    player.x = clamp(player.x + player.vx*dt, 16, W-16);

    player.cooldown = Math.max(0, player.cooldown - dt);

    pizza.x += pizza.vx*dt;
    if (pizza.x < 46){ pizza.x = 46; pizza.vx *= -1; }
    if (pizza.x > W-46){ pizza.x = W-46; pizza.vx *= -1; }

    if (combo > 1){
      comboTimer -= dt;
      if (comboTimer <= 0){
        combo = 1;
        comboEl.textContent = 'x1';
      }
    }

    for (let i=bullets.length-1; i>=0; i--){
      const b = bullets[i];
      b.x += b.vx*dt;
      b.y += b.vy*dt;
      b.vy += 260*dt;
      b.life -= dt;

      const dx = b.x - pizza.x;
      const dy = b.y - pizza.y;
      const hit = (dx*dx + dy*dy) <= (pizza.r+3)*(pizza.r+3);

      if (hit){
        bullets.splice(i,1);
        onHit(b.x,b.y);
        continue;
      }

      if (b.y > H+10 || b.life <= 0) bullets.splice(i,1);
    }

    for (let i=crumbs.length-1; i>=0; i--){
      const p = crumbs[i];
      p.x += p.vx*dt;
      p.y += p.vy*dt;
      p.vy += 380*dt;
      p.life -= dt;
      if (p.life <= 0) crumbs.splice(i,1);
    }

    for (const s of stars){
      s.y += s.v*dt;
      if (s.y > H){ s.y = -2; s.x = Math.random()*W; }
    }
  }

  function onHit(x,y){
    const add = 10 * combo;
    score += add;
    scoreEl.textContent = score;

    combo = Math.min(9, combo + 1);
    comboTimer = 1.35;
    comboEl.textContent = `x${combo}`;

    for (let i=0;i<10;i++){
      crumbs.push({ x, y, vx: rnd(-60,60), vy: rnd(-140,-40), life: rnd(0.25,0.55) });
    }

    beep(660 + combo*40, 0.05, 'square', 0.025);
  }

  function render(){
    ctx.fillStyle = '#050712';
    ctx.fillRect(0,0,W,H);

    ctx.fillStyle = '#93c5fd';
    for (const s of stars) ctx.fillRect(s.x|0, s.y|0, s.s, s.s);

    ctx.fillStyle = '#c7d2fe';
    ctx.font = '10px monospace';
    ctx.fillText('AROMAT PIZZA 1986', 8, 14);

    drawPizza(pizza.x, pizza.y, pizza.r);

    // grains
    ctx.fillStyle = '#fbbf24';
    for (const b of bullets) ctx.fillRect((b.x|0), (b.y|0), 2, 2);

    // crumbs
    ctx.fillStyle = '#ffe88a';
    for (const p of crumbs) ctx.fillRect((p.x|0), (p.y|0), 2, 2);

    drawAromatJar(player.x, player.y);

    ctx.fillStyle = '#111827';
    ctx.fillRect(0, H-12, W, 12);

    if (!running && timeLeft <= 0){
      ctx.fillStyle = 'rgba(0,0,0,0.65)';
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = '#fbbf24';
      ctx.font = '14px monospace';
      ctx.fillText('TIME UP', 124, 82);
      ctx.fillStyle = '#c7d2fe';
      ctx.font = '10px monospace';
      ctx.fillText(`SCORE: ${score}`, 120, 98);
      ctx.fillText('Premi Start/Restart', 92, 114);
    }

    drawCRT();
  }

  reset();
  render();
})();
</script>
</body>
</html>
