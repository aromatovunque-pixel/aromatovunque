<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Aromat World Mobile</title>
  <style>
    :root { color-scheme: dark; }
    html, body {
      height: 100%;
      margin: 0;
      background:#0b1020;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      touch-action: none; /* important: avoid scroll/pinch while playing */
      overscroll-behavior: none;
    }
    .wrap {
      height: 100%;
      display:flex;
      align-items:center;
      justify-content:center;
      position: relative;
    }
    canvas {
      width: 100vw;
      height: 100vh;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      background:#1a2a4a;
      display:block;
    }
    .hud {
      position: fixed;
      top: 10px; left: 10px; right: 10px;
      display:flex; justify-content:space-between; gap:10px;
      pointer-events:none;
      z-index: 20;
      font-size: 12px;
    }
    .pill {
      background: rgba(10,15,30,.55);
      border:1px solid rgba(120,160,255,.25);
      padding:8px 10px;
      border-radius:999px;
      pointer-events:none;
      max-width: 70vw;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .pill strong { color:#cfe0ff; }

    /* --- Touch controls --- */
    .controls {
      position: fixed;
      left: 0; right: 0; bottom: 0;
      height: 42vh;
      max-height: 340px;
      display:flex;
      justify-content: space-between;
      align-items: flex-end;
      padding: 14px;
      z-index: 30;
      pointer-events: none; /* enable only on buttons */
      background: linear-gradient(to top, rgba(0,0,0,.25), rgba(0,0,0,0));
    }
    .pad, .actions { display:flex; gap:12px; pointer-events: auto; }
    .btn {
      width: 76px; height: 76px;
      border-radius: 18px;
      border: 1px solid rgba(180,210,255,.22);
      background: rgba(10,15,30,.45);
      box-shadow: 0 10px 22px rgba(0,0,0,.35);
      display:flex;
      align-items:center;
      justify-content:center;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      touch-action: none;
      font-weight: 800;
      letter-spacing: .5px;
    }
    .btn:active { transform: translateY(1px); background: rgba(10,15,30,.60); }
    .btn.small { width: 70px; height: 70px; border-radius: 16px; font-weight: 900; }
    .btn.jump { width: 92px; height: 92px; border-radius: 22px; font-size: 14px; }
    .btn.dash { width: 82px; height: 82px; border-radius: 20px; font-size: 13px; }
    .btn span { opacity: .92; }
    .hint2 {
      position: fixed;
      bottom: calc(42vh + 6px);
      left: 10px; right: 10px;
      text-align:center;
      z-index: 25;
      opacity: .7;
      font-size: 11px;
      pointer-events:none;
    }
    @media (min-width: 900px) {
      /* On desktop it still works, but buttons are less annoying */
      .controls { height: 240px; }
      canvas { width: 960px; height: 540px; border:2px solid #22345c; border-radius:10px; }
    }
  </style>
</head>
<body>
  <div class="hud">
    <div class="pill"><strong>AROMAT WORLD</strong> · touch controls</div>
    <div class="pill" id="hudRight">Granelli: 0 · Vite: 3 · Livello: 1</div>
  </div>

  <div class="wrap">
    <canvas id="c" width="960" height="540"></canvas>
  </div>

  <div class="hint2">Suggerimento: tieni premuto ←/→ per correre, SALTA per saltare, DASH per sprint</div>

  <div class="controls">
    <div class="pad">
      <div class="btn small" id="btnLeft"><span>←</span></div>
      <div class="btn small" id="btnRight"><span>→</span></div>
    </div>
    <div class="actions">
      <div class="btn dash" id="btnDash"><span>DASH</span></div>
      <div class="btn jump" id="btnJump"><span>SALTA</span></div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const hudRight = document.getElementById('hudRight');

  // --- Touch input state (mobile-first) ---
  const input = {
    left:false, right:false,
    jumpPressed:false, // edge
    dashPressed:false  // edge
  };

  function bindHold(btn, onDown, onUp) {
    const down = (e) => { e.preventDefault(); onDown(); };
    const up = (e) => { e.preventDefault(); onUp(); };

    btn.addEventListener('pointerdown', down, {passive:false});
    btn.addEventListener('pointerup', up, {passive:false});
    btn.addEventListener('pointercancel', up, {passive:false});
    btn.addEventListener('pointerleave', up, {passive:false});
    btn.addEventListener('lostpointercapture', up, {passive:false});
  }

  bindHold(document.getElementById('btnLeft'),
    () => { input.left = true; },
    () => { input.left = false; }
  );
  bindHold(document.getElementById('btnRight'),
    () => { input.right = true; },
    () => { input.right = false; }
  );
  bindHold(document.getElementById('btnJump'),
    () => { input.jumpPressed = true; },
    () => {}
  );
  bindHold(document.getElementById('btnDash'),
    () => { input.dashPressed = true; },
    () => {}
  );

  // Optional: swipe up anywhere to jump, quick tap right side to dash (kept simple)
  let touchStartY = null, touchStartX = null;
  window.addEventListener('pointerdown', (e) => {
    // ignore if pressing buttons (they already handle)
    if (e.target.classList && e.target.classList.contains('btn')) return;
    touchStartY = e.clientY;
    touchStartX = e.clientX;
  }, {passive:true});

  window.addEventListener('pointerup', (e) => {
    if (touchStartY == null) return;
    const dy = touchStartY - e.clientY;
    const dx = Math.abs((touchStartX ?? e.clientX) - e.clientX);

    // swipe up to jump
    if (dy > 35 && dx < 120) input.jumpPressed = true;

    // quick tap on right third to dash (if not a swipe)
    const tap = Math.abs(dy) < 15 && dx < 15;
    if (tap && e.clientX > window.innerWidth * 0.66) input.dashPressed = true;

    touchStartY = null; touchStartX = null;
  }, {passive:true});

  // Prevent double-tap zoom on iOS-ish browsers
  let lastTap = 0;
  window.addEventListener('touchend', (e) => {
    const now = Date.now();
    if (now - lastTap < 300) e.preventDefault();
    lastTap = now;
  }, {passive:false});

  // --- Helpers ---
  const clamp = (v,a,b) => Math.max(a, Math.min(b,v));
  const aabb = (a,b) => a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;

  // --- World/physics ---
  const TILE = 24;
  const GRAV = 1700;
  const FRICTION = 0.86;
  const AIR_FRICTION = 0.93;

  const levels = [
`................................................................
................................................................
................................................................
....................o....o.................o....................
.............o..................o...............................
......................#######...................................
...............####.............................................
....................................................o...........
...........o..............................#######...............
.....................E..........................................
################..###########.....##############################
################..###########.....##############################
`,
`................................................................
................................................................
................................................................
..............o..............o..................................
.....................#######....................................
.............####...............................................
..............................................o.................
.......o...........................#####........................
..................E.............................................
##############.............####################.....G...........
##############....^..^..^..####################..#######..######
##############..###############################..#######..######
`
  ];

  function makeEnemy(x,y){
    return { x,y,w:18,h:18, vx:(Math.random()<.5?-1:1)*120, vy:0, alive:true, stompedTimer:0 };
  }

  function parseLevel(str){
    const rows = str.trimEnd().split("\n");
    const h = rows.length;
    const w = Math.max(...rows.map(r => r.length));
    const tiles = [];
    const items = [];
    const enemies = [];
    let goal = null;

    for (let y=0;y<h;y++){
      tiles[y]=[];
      const row = rows[y].padEnd(w,'.');
      for (let x=0;x<w;x++){
        const ch = row[x];
        if (ch === '#') tiles[y][x] = '#';
        else if (ch === '^') tiles[y][x] = '^';
        else tiles[y][x] = '.';

        if (ch === 'o') items.push({x:x*TILE+8,y:y*TILE+8,w:8,h:8,taken:false});
        if (ch === 'E') enemies.push(makeEnemy(x*TILE+2,y*TILE+6));
        if (ch === 'G') goal = {x:x*TILE,y:y*TILE,w:TILE,h:TILE};
      }
    }
    if (!goal) goal = {x:(w-3)*TILE, y:(h-4)*TILE, w:TILE, h:TILE};
    return { tiles, w, h, items, enemies, goal };
  }

  function tileAt(world, px, py){
    const tx = Math.floor(px / TILE), ty = Math.floor(py / TILE);
    if (ty<0 || ty>=world.h || tx<0 || tx>=world.w) return '.';
    return world.tiles[ty][tx] || '.';
  }
  const isSolid = (t) => t === '#';
  const isSpike = (t) => t === '^';

  const cam = {x:0,y:0};

  const player = {
    x:72,y:72,w:18,h:26,
    vx:0,vy:0,
    onGround:false,
    facing:1,
    coyote:0,
    jumpBuffer:0,
    dashTimer:0,
    invuln:0,
    lives:3,
    score:0,
    level:0
  };

  function respawn(){
    player.x = 72; player.y = 48;
    player.vx = 0; player.vy = 0;
    player.onGround = false;
    player.coyote = 0;
    player.jumpBuffer = 0;
    player.dashTimer = 0;
    player.invuln = 1.1;
  }

  function loadLevel(idx){
    const w = parseLevel(levels[idx % levels.length]);
    respawn();
    return w;
  }

  let world = loadLevel(player.level);

  function restartGame(){
    player.lives = 3;
    player.score = 0;
    player.level = 0;
    world = loadLevel(player.level);
  }

  function moveAndCollide(ent, dt, world){
    // X
    ent.x += ent.vx * dt;
    let left = Math.floor(ent.x / TILE);
    let right = Math.floor((ent.x + ent.w - 1) / TILE);
    let top = Math.floor(ent.y / TILE);
    let bottom = Math.floor((ent.y + ent.h - 1) / TILE);

    for (let ty=top; ty<=bottom; ty++){
      for (let tx=left; tx<=right; tx++){
        const t = (world.tiles[ty] && world.tiles[ty][tx]) ? world.tiles[ty][tx] : '.';
        if (!isSolid(t)) continue;
        const r = {x:tx*TILE,y:ty*TILE,w:TILE,h:TILE};
        if (aabb(ent,r)){
          if (ent.vx > 0) ent.x = r.x - ent.w;
          else if (ent.vx < 0) ent.x = r.x + r.w;
          ent.vx = 0;
        }
      }
    }

    // Y
    ent.y += ent.vy * dt;
    ent.onGround = false;

    left = Math.floor(ent.x / TILE);
    right = Math.floor((ent.x + ent.w - 1) / TILE);
    top = Math.floor(ent.y / TILE);
    bottom = Math.floor((ent.y + ent.h - 1) / TILE);

    for (let ty=top; ty<=bottom; ty++){
      for (let tx=left; tx<=right; tx++){
        const t = (world.tiles[ty] && world.tiles[ty][tx]) ? world.tiles[ty][tx] : '.';
        if (!isSolid(t)) continue;
        const r = {x:tx*TILE,y:ty*TILE,w:TILE,h:TILE};
        if (aabb(ent,r)){
          if (ent.vy > 0){ ent.y = r.y - ent.h; ent.onGround = true; }
          else if (ent.vy < 0){ ent.y = r.y + r.h; }
          ent.vy = 0;
        }
      }
    }
  }

  function touchingSpikes(ent, world){
    const pts = [
      [ent.x+2, ent.y+ent.h-1],
      [ent.x+ent.w-3, ent.y+ent.h-1],
      [ent.x+ent.w/2, ent.y+ent.h-1],
      [ent.x+2, ent.y+2],
      [ent.x+ent.w-3, ent.y+2],
    ];
    return pts.some(([px,py]) => isSpike(tileAt(world, px, py)));
  }

  function hurt(){
    if (player.invuln > 0) return;
    player.lives--;
    player.invuln = 1.4;
    player.vx = -player.facing * 220;
    player.vy = -420;
    if (player.lives < 0) restartGame();
  }

  // --- Loop ---
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  function update(dt){
    // timers
    player.coyote = Math.max(0, player.coyote - dt);
    player.jumpBuffer = Math.max(0, player.jumpBuffer - dt);
    player.dashTimer = Math.max(0, player.dashTimer - dt);
    player.invuln = Math.max(0, player.invuln - dt);

    // Convert touch presses into buffers (edge)
    if (input.jumpPressed) { player.jumpBuffer = 0.12; input.jumpPressed = false; }
    const dashEdge = input.dashPressed; input.dashPressed = false;

    // movement
    const left = input.left;
    const right = input.right;

    const maxSpeed = (player.dashTimer > 0) ? 360 : 210;
    const accel = (player.onGround ? 1350 : 900);

    if (left){ player.vx -= accel * dt; player.facing = -1; }
    if (right){ player.vx += accel * dt; player.facing =  1; }

    if (player.onGround) player.vx *= (left || right) ? 0.94 : FRICTION;
    else player.vx *= AIR_FRICTION;

    player.vx = clamp(player.vx, -maxSpeed, maxSpeed);

    if (dashEdge && player.dashTimer <= 0){
      player.dashTimer = 0.22;
      player.vx = player.facing * 360;
      player.vy = Math.min(player.vy, 80);
    }

    player.vy += GRAV * dt;
    player.vy = Math.min(player.vy, 1200);

    if (player.onGround) player.coyote = 0.10;

    if (player.jumpBuffer > 0 && (player.onGround || player.coyote > 0)){
      player.jumpBuffer = 0;
      player.coyote = 0;
      player.vy = -560;
      player.onGround = false;
    }

    moveAndCollide(player, dt, world);

    if (touchingSpikes(player, world)) hurt();
    if (player.y > world.h*TILE + 200) hurt();

    // collect
    for (const g of world.items){
      if (!g.taken && aabb(player, g)){
        g.taken = true;
        player.score += 10;
      }
    }

    // enemies
    for (const e of world.enemies){
      if (!e.alive) continue;

      e.vy += GRAV * dt;
      e.vy = Math.min(e.vy, 1200);

      const aheadX = e.x + (e.vx > 0 ? e.w + 2 : -2);
      const footY = e.y + e.h + 2;
      const groundAhead = isSolid(tileAt(world, aheadX, footY));
      const wallAhead = isSolid(tileAt(world, aheadX, e.y + e.h/2));
      if (!groundAhead || wallAhead) e.vx *= -1;

      moveAndCollide(e, dt, world);

      if (aabb(player, e) && player.invuln <= 0){
        const playerBottomPrev = player.y + player.h - player.vy * dt;
        const stomp = (player.vy > 120) && (playerBottomPrev <= e.y + 6);
        if (stomp){
          e.alive = false;
          e.stompedTimer = 0.18;
          player.vy = -360;
          player.score += 25;
        } else {
          hurt();
        }
      }
    }

    // goal
    if (aabb(player, world.goal)){
      player.level++;
      world = loadLevel(player.level);
      player.score += 100;
    }

    // camera
    const targetX = player.x + player.w/2 - W/2;
    const targetY = player.y + player.h/2 - H/2;
    cam.x += (targetX - cam.x) * 0.12;
    cam.y += (targetY - cam.y) * 0.10;
    cam.x = clamp(cam.x, 0, Math.max(0, world.w*TILE - W));
    cam.y = clamp(cam.y, 0, Math.max(0, world.h*TILE - H));

    const remaining = world.items.filter(i => !i.taken).length;
    hudRight.textContent = `Granelli: ${player.score} · Vite: ${Math.max(0, player.lives)} · Livello: ${player.level+1} · Rimasti: ${remaining}`;
  }

  // --- Draw ---
  function draw(){
    ctx.clearRect(0,0,W,H);

    // sky dots parallax
    ctx.save();
    ctx.translate(-cam.x*0.2, -cam.y*0.2);
    ctx.globalAlpha = 0.35;
    for (let i=0;i<140;i++){
      const x = (i*97)% (world.w*TILE + W);
      const y = (i*53)% (world.h*TILE + H);
      ctx.fillStyle = (i%3===0) ? "#9bc2ff" : "#cfe0ff";
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.restore();
    ctx.globalAlpha = 1;

    ctx.save();
    ctx.translate(-Math.floor(cam.x), -Math.floor(cam.y));

    for (let y=0;y<world.h;y++){
      for (let x=0;x<world.w;x++){
        const t = world.tiles[y][x];
        if (t === '.') continue;
        const px = x*TILE, py = y*TILE;
        if (t === '#') drawBlock(px,py);
        if (t === '^') drawSpike(px,py);
      }
    }

    drawGoal(world.goal.x, world.goal.y);

    for (const g of world.items) if (!g.taken) drawGranule(g.x,g.y);

    for (const e of world.enemies){
      if (e.alive) drawEnemy(e);
      else if (e.stompedTimer > 0){ drawPuff(e.x,e.y); e.stompedTimer -= 1/60; }
    }

    drawAromatHero(player);

    ctx.restore();
  }

  function drawBlock(x,y){
    ctx.fillStyle = "#2d8a4d"; ctx.fillRect(x,y,TILE,TILE);
    ctx.fillStyle = "#38a85f"; ctx.fillRect(x+2,y+2,TILE-4,TILE-4);
    ctx.fillStyle = "rgba(0,0,0,.25)"; ctx.fillRect(x+2,y+TILE-6,TILE-4,4);
    ctx.fillStyle = "#f0d04f"; ctx.fillRect(x+3,y+9,TILE-6,4);
    ctx.fillStyle = "rgba(255,255,255,.20)"; ctx.fillRect(x+3,y+6,4,12);
  }

  function drawSpike(x,y){
    ctx.fillStyle = "#c9d4ff";
    ctx.fillRect(x, y, TILE, TILE);
    ctx.fillStyle = "#ff5a6a";
    for (let i=0;i<4;i++){
      const sx = x + i*(TILE/4);
      ctx.beginPath();
      ctx.moveTo(sx+2, y+TILE-2);
      ctx.lineTo(sx+TILE/8+2, y+6);
      ctx.lineTo(sx+TILE/4-2, y+TILE-2);
      ctx.closePath();
      ctx.fill();
    }
  }

  function drawGranule(x,y){
    ctx.fillStyle = "#f7f0c6";
    ctx.fillRect(x, y, 8, 8);
    ctx.fillStyle = "rgba(0,0,0,.20)";
    ctx.fillRect(x+1, y+5, 6, 2);
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(x+2, y+2, 2, 2);
  }

  function drawGoal(x,y){
    ctx.fillStyle = "#dfe8ff";
    ctx.fillRect(x+10, y-48, 4, 72);
    ctx.fillStyle = "#ff3b4d";
    ctx.fillRect(x+14, y-44, 22, 14);
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(x+22, y-41, 6, 8);
    ctx.fillRect(x+20, y-39, 10, 4);
    ctx.fillStyle = "#f0d04f";
    ctx.fillRect(x, y, TILE, TILE);
    ctx.fillStyle = "#2d8a4d";
    ctx.fillRect(x+3, y+3, TILE-6, TILE-6);
  }

  function drawEnemy(e){
    ctx.fillStyle = "#c58a2a";
    ctx.fillRect(e.x, e.y, e.w, e.h);
    ctx.fillStyle = "#e0b352";
    ctx.fillRect(e.x+2, e.y+2, e.w-4, e.h-4);
    ctx.fillStyle = "#2b1a0c";
    ctx.fillRect(e.x+5, e.y+7, 3, 3);
    ctx.fillRect(e.x+e.w-8, e.y+7, 3, 3);
    ctx.fillRect(e.x+7, e.y+12, e.w-14, 2);
  }

  function drawPuff(x,y){
    ctx.fillStyle = "rgba(255,255,255,.7)";
    ctx.fillRect(x+4,y+8,6,4);
    ctx.fillRect(x+10,y+6,6,6);
    ctx.fillRect(x+14,y+10,4,4);
  }

  function drawAromatHero(p){
    if (p.invuln > 0 && Math.floor(p.invuln*18)%2===0) ctx.globalAlpha = 0.45;

    const x=p.x, y=p.y;
    ctx.fillStyle = "#e3343b"; ctx.fillRect(x, y, p.w, 6);
    ctx.fillStyle = "rgba(255,255,255,.25)"; ctx.fillRect(x+2, y+1, 4, 3);

    ctx.fillStyle = "#f0d04f"; ctx.fillRect(x, y+6, p.w, p.h-6);
    ctx.fillStyle = "#1f7a49"; ctx.fillRect(x, y+12, p.w, 7);
    ctx.fillStyle = "rgba(255,255,255,.18)"; ctx.fillRect(x+2, y+8, 3, p.h-10);

    ctx.fillStyle = "#1b1f2a";
    ctx.fillRect(x+5, y+16, 3, 3);
    ctx.fillRect(x+p.w-8, y+16, 3, 3);
    ctx.fillRect(x+7, y+21, p.w-14, 2);

    ctx.fillStyle = "#2b1a0c";
    ctx.fillRect(x+3, y+p.h-2, 5, 2);
    ctx.fillRect(x+p.w-8, y+p.h-2, 5, 2);

    if (p.dashTimer > 0){
      ctx.fillStyle = "#cfe0ff";
      const sx = x - p.facing*8;
      ctx.fillRect(sx, y+16, 6, 2);
      ctx.fillRect(sx-2, y+14, 4, 2);
      ctx.fillRect(sx-1, y+18, 4, 2);
    }

    ctx.globalAlpha = 1;
  }

  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
